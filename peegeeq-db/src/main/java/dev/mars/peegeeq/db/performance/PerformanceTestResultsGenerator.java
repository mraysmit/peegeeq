package dev.mars.peegeeq.db.performance;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Utility for generating standardized performance test results with system information.
 * 
 * This class provides a template-based approach to generating performance test reports
 * that automatically include system configuration details, ensuring consistent
 * documentation across all performance tests.
 * 
 * @author Mark Andrew Ray-Smith Cityline Ltd
 * @since 2025-09-11
 * @version 1.0
 */
public class PerformanceTestResultsGenerator {
    private static final Logger logger = LoggerFactory.getLogger(PerformanceTestResultsGenerator.class);
    
    private final String testSuiteName;
    private final String testEnvironment;
    private final Map<String, Object> systemInfo;
    private final List<TestResult> testResults;
    private final Map<String, String> additionalInfo;
    
    public PerformanceTestResultsGenerator(String testSuiteName, String testEnvironment) {
        this.testSuiteName = testSuiteName;
        this.testEnvironment = testEnvironment;
        this.systemInfo = SystemInfoCollector.collectSystemInfo();
        this.testResults = new ArrayList<>();
        this.additionalInfo = new LinkedHashMap<>();
    }
    
    /**
     * Adds a test result to the report.
     */
    public PerformanceTestResultsGenerator addTestResult(String testName, String status, 
                                                        String duration, Map<String, Object> metrics) {
        testResults.add(new TestResult(testName, status, duration, metrics));
        return this;
    }
    
    /**
     * Adds additional information to the report.
     */
    public PerformanceTestResultsGenerator addAdditionalInfo(String key, String value) {
        additionalInfo.put(key, value);
        return this;
    }
    
    /**
     * Generates the complete performance test results report in markdown format.
     */
    public String generateReport() {
        StringBuilder report = new StringBuilder();
        
        // Header
        report.append("# ").append(testSuiteName).append(" Performance Test Results\n");
        report.append("**Date:** ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("MMMM d, yyyy"))).append("  \n");
        report.append("**Test Environment:** ").append(testEnvironment).append("  \n");
        
        // Add Vert.x version if available
        String vertxVersion = System.getProperty("vertx.version", "5.x with optimizations applied");
        report.append("**Vert.x Version:** ").append(vertxVersion).append("  \n\n");
        
        // Executive Summary
        report.append("## üìä Executive Summary\n\n");
        report.append(generateExecutiveSummary());
        
        // System Configuration
        report.append("\n").append(SystemInfoCollector.formatAsMarkdown(systemInfo));
        
        // Detailed Test Results
        report.append("\n## üéØ Detailed Test Results\n\n");
        report.append(generateDetailedResults());
        
        // Additional Information
        if (!additionalInfo.isEmpty()) {
            report.append("\n## üìã Additional Information\n\n");
            for (Map.Entry<String, String> entry : additionalInfo.entrySet()) {
                report.append("- **").append(entry.getKey()).append(":** ").append(entry.getValue()).append("\n");
            }
        }
        
        // Footer
        report.append("\n---\n\n");
        report.append("**Test Report Generated:** ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("MMMM d, yyyy 'at' HH:mm:ss"))).append("  \n");
        report.append("**Report Timestamp:** ").append(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)).append("  \n");
        report.append("**Generated By:** Augment Agent - PeeGeeQ Performance Test System  \n");
        
        return report.toString();
    }
    
    /**
     * Generates the executive summary table.
     */
    private String generateExecutiveSummary() {
        StringBuilder summary = new StringBuilder();
        
        summary.append("| Implementation | Status | Duration | Key Metrics | Notes |\n");
        summary.append("|----------------|--------|----------|-------------|-------|\n");
        
        for (TestResult result : testResults) {
            summary.append("| **").append(result.testName).append("** | ");
            summary.append(formatStatus(result.status)).append(" | ");
            summary.append(result.duration).append(" | ");
            summary.append(formatKeyMetrics(result.metrics)).append(" | ");
            summary.append(formatNotes(result.metrics)).append(" |\n");
        }
        
        return summary.toString();
    }
    
    /**
     * Generates detailed test results.
     */
    private String generateDetailedResults() {
        StringBuilder details = new StringBuilder();
        
        int testNumber = 1;
        for (TestResult result : testResults) {
            details.append("### ").append(testNumber).append(". ").append(result.testName).append("\n");
            details.append("**Status:** ").append(formatStatus(result.status)).append("  \n");
            details.append("**Duration:** ").append(result.duration).append("  \n\n");
            
            details.append("**Key Metrics:**\n");
            for (Map.Entry<String, Object> metric : result.metrics.entrySet()) {
                details.append("- **").append(metric.getKey()).append(":** ").append(metric.getValue()).append("\n");
            }
            
            details.append("\n");
            testNumber++;
        }
        
        return details.toString();
    }
    
    /**
     * Formats test status with appropriate emoji.
     */
    private String formatStatus(String status) {
        switch (status.toUpperCase()) {
            case "PASSED":
            case "SUCCESS":
                return "‚úÖ **PASSED**";
            case "FAILED":
            case "FAILURE":
                return "‚ùå **FAILED**";
            case "PARTIAL":
            case "WARNING":
                return "‚ö†Ô∏è **PARTIAL**";
            case "SKIPPED":
                return "‚è≠Ô∏è **SKIPPED**";
            default:
                return status;
        }
    }
    
    /**
     * Formats key metrics for the summary table.
     */
    private String formatKeyMetrics(Map<String, Object> metrics) {
        StringBuilder keyMetrics = new StringBuilder();
        
        // Look for common performance metrics
        if (metrics.containsKey("throughput")) {
            keyMetrics.append(metrics.get("throughput")).append(" msg/sec");
        }
        if (metrics.containsKey("latency")) {
            if (keyMetrics.length() > 0) keyMetrics.append(", ");
            keyMetrics.append(metrics.get("latency")).append(" latency");
        }
        if (metrics.containsKey("events")) {
            if (keyMetrics.length() > 0) keyMetrics.append(", ");
            keyMetrics.append(metrics.get("events")).append(" events");
        }
        
        return keyMetrics.length() > 0 ? keyMetrics.toString() : "See details";
    }
    
    /**
     * Formats notes for the summary table.
     */
    private String formatNotes(Map<String, Object> metrics) {
        if (metrics.containsKey("notes")) {
            return metrics.get("notes").toString();
        }
        if (metrics.containsKey("improvement")) {
            return metrics.get("improvement").toString();
        }
        return "Standard performance";
    }
    
    /**
     * Saves the report to a file.
     */
    public void saveToFile(String filename) {
        try {
            java.nio.file.Files.write(
                java.nio.file.Paths.get(filename), 
                generateReport().getBytes()
            );
            logger.info("Performance test results saved to: {}", filename);
        } catch (Exception e) {
            logger.error("Failed to save performance test results to file: {}", filename, e);
        }
    }
    
    /**
     * Test result data structure.
     */
    public static class TestResult {
        final String testName;
        final String status;
        final String duration;
        final Map<String, Object> metrics;
        
        public TestResult(String testName, String status, String duration, Map<String, Object> metrics) {
            this.testName = testName;
            this.status = status;
            this.duration = duration;
            this.metrics = metrics != null ? metrics : new LinkedHashMap<>();
        }
    }
    
    /**
     * Builder pattern for creating performance test results.
     */
    public static class Builder {
        private final PerformanceTestResultsGenerator generator;
        
        public Builder(String testSuiteName, String testEnvironment) {
            this.generator = new PerformanceTestResultsGenerator(testSuiteName, testEnvironment);
        }
        
        public Builder addTest(String testName, String status, String duration) {
            generator.addTestResult(testName, status, duration, new LinkedHashMap<>());
            return this;
        }
        
        public Builder addTestWithMetrics(String testName, String status, String duration, Map<String, Object> metrics) {
            generator.addTestResult(testName, status, duration, metrics);
            return this;
        }
        
        public Builder addInfo(String key, String value) {
            generator.addAdditionalInfo(key, value);
            return this;
        }
        
        public PerformanceTestResultsGenerator build() {
            return generator;
        }
    }
}
